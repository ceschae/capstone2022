package Scripts;

import java.io.FileWriter;
import java.io.IOException;
import java.util.HashSet;
import java.util.Random;
import java.util.Set;

public class OntologyTrie extends Trie {
    private Set<Relationship> links;
    private Set<OntologyNode> nodes;

    public OntologyTrie(Trie t) {
        this.links = new HashSet<Relationship>();
        this.nodes = new HashSet<OntologyNode>();
        for (TrieNode parent : t.getNonBranchNodes()) {
            OntologyNode p = new OntologyNode(parent.value, parent.fullPath);
            nodes.add(p);
            Set<TrieNode> children = findAllChildren(parent);
            for (TrieNode child : children) {
                addChildLink(p, child);
            }
        }
    }

    private void addChildLink(OntologyNode p, TrieNode child) {
        OntologyNode c = new OntologyNode(child.value, child.fullPath);
        nodes.add(c); // won't add duplicates since it's a hash set and OntologyNode overrides the relevant methods
        Relationship r = new Relationship(c, Relationship.RelationshipType.NARROW_BROAD, p);
        // ok i know it's bad to add it in three places. sue me
        this.links.add(r);
        p.links.add(r);
        c.links.add(r);
    }

    private Set<TrieNode> findAllChildren(TrieNode parent) {
        Set<TrieNode> children = new HashSet<TrieNode>();
        for (TrieNode child : parent.children) {
            // don't add relationships between branch nodes,
            // definitely don't do it for null children
            if (child != null) {
                if (child.value != -1) {
                    // stop here, add the child, move on to next child
                    children.add(child);
                } else {
                    // recurse down to find all non-branch nodes (e.g. create direct links)
                    Set<TrieNode> result = findAllChildren(child);
                    children.addAll(result);
                }
            }
        }
        return children;
    }

    // Adds n random relationships to the set of links
    public void addNRelationships(int n) {
        Random r = new Random();
        Relationship.RelationshipType[] types = Relationship.RelationshipType.values();
        int nodesSize = this.nodes.size();
        OntologyNode[] nodesArray = this.nodes.toArray(new OntologyNode[nodesSize]);
        for (int i = 0; i < n; i++) {
            OntologyNode a = nodesArray[r.nextInt(nodesSize)];
            OntologyNode b = nodesArray[r.nextInt(nodesSize)];
            if (!a.equals(b)) {
                Relationship rel = new Relationship(a, types[r.nextInt(types.length)], b);
                links.add(rel);
                a.links.add(rel);
                b.links.add(rel);
            } else {
                i--;
            }
        }
    }

    @Override
    public double averagePathLength() {
        // TODO Auto-generated method stub
        return 0;
    }

    @Override
    public double clusteringCoefficient() {
        // TODO Auto-generated method stub
        return 0;
    }

    @Override
    public void outputEncoding(FileWriter f) {
        try {
            f.write("DO NOT EDIT!! This file is generated by Trie.java\n");
            f.write("-------------------------------------------------\n\n");
            for (Relationship r : this.links) {
                f.write(new CallNumber(r.a.path).toString());
                f.write(" <- " + Relationship.relationshipTypeToString(r.type) + " -> ");
                f.write(new CallNumber(r.b.path).toString() + "\n");
            }
        } catch (IOException e) {
            System.out.println("File IO Exception occurred: " + e);
        }
    }
    
}
